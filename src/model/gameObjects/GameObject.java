package model.gameObjects;

import model.actionResults.ActionResult;
import model.playerClasses.Player;

public interface GameObject {

    /*
    Най-голямата ми гордост в този проект.
    Благодарение на тези две функции не ми се налага всеки път да се интересувам какви са обектите, които стоят на картата като GameObject,
    защото всеки обект си знае как да реагира, когато бъде достъпен чрез преместване или бъде атакуван

    Въпроси и отговори:

    Въпрос: Добре, едната функция не е ли за предмети, а другата за чудовища?
    Отговор: Не! И предметите, и чудовищата могат да бъда атакувани или пък играча да се мести върху тях.
    Ако погледнете имплементации на тези две функции във съответните класове, ще видите какво се случва.

    Въпрос: Защо предмети/чудовища/стени/празнини извършват действия върху играча, а не играча върху тях?
    Отговор: Функциите се казват Collide..., което значи, че дефинират поведение когато предмет/чудовище/не знам си какво
    е в колизия с играча след такава операция. Вътре в самите имплементации играча върши действията, или пък се дифинира друго
    поведение, трябва погледнете в детайли.

    Въпрос: Защо реши да го направиш така?
    Отговор: Защото това е най-добрия възможен начин, благодарие на който се спазват всички ООП принципи.
    Не ми трябва да се интересувам какви са конкретните обекти, които стоят на тази позиция!
    представете си че имахме следната конструкция:
    class Shape, наследен от class Rectangle и клас Circle.
    Ако искаме да направим intersect() функция, то трябва всеки път да се интересуваме какви са реалните типове на обектите,
    за да извикаме правилната функция.
    Затова решението на този проблем е да направим функция intersect(Shape Other) в базовия клас, която всеки наследния да презаписва
    по следния начин:
    class Rectangle: void intersect(Shape other){ other.intersectWithRectangle(this)}
    class Circle: void intersect(Shape other) {other.intersectWithCircle(this)}
    Този design pattern се нарича visitor, и при него ролите се обръщат - this иска да intersect-не с other, но реалната имплементация е
    other интерсектва с this, като целта е да не се интересуваме от контретните типове!
    Тук имаме нещо подобно на visitor, само че вместо да направя функции collideWithEnemy, collideWithItem ..., които реално не ми вършат работа,
    защото чудовище не може да влезе в контакт с друго, същото и за предметите се отнася, аз прява две функции, за да може всеки наследник да каже какво
    ще прави, когато влезе в контакт с играча
    Надявам се да разбирате!

    Въпрос: Защо не разделиш функциите move и attack?
    Отговор: ??? Те са разделени, no?

     */

    public abstract ActionResult collideOnMovement(Player player);
    public abstract ActionResult collideOnAttack(Player player);
}
